\documentclass[UTF8]{report}
\usepackage{wrapfig}
%\usepackage{ctex}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{listings}
\usepackage{algorithm,float}  
\usepackage{algorithmicx}  
\usepackage{algpseudocode} 
\usepackage{ulem}
\usepackage{fontspec}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{autobreak}
\usepackage{longtable}
\usepackage{changepage}
\usepackage{dcolumn}
\usepackage{multirow}
\usepackage{caption}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{autobreak}
\usepackage{appendix}
\usepackage{pdfpages}
\definecolor{CPPLigh!t}  {HTML} {686868}
\definecolor{CPPSteel}  {HTML} {888888}
\definecolor{CPPDark}   {HTML} {262626}
\definecolor{CPPBlue}   {HTML} {4172A3}
\definecolor{CPPGreen}  {HTML} {487818}
\definecolor{CPPBrown}  {HTML} {A07040}
\definecolor{CPPRed}    {HTML} {AD4D3A}
\definecolor{CPPViolet} {HTML} {7040A0}
\definecolor{CPPGray}  {HTML} {B8B8B8}
\lstset{
    columns=fixed,
    numbers=left,
    frame=none,
    backgroundcolor=\color[RGB]{245,245,244},
    keywordstyle=\color[RGB]{40,40,255},
    numberstyle=\footnotesize\color{darkgray},
    commentstyle=\it\color[RGB]{0,96,96},
    stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},
    showstringspaces=false,
    language=c++,
    morekeywords={alignas,continute,friend,register,true,alignof,decltype,goto,
    reinterpret_cast,try,asm,defult,if,return,typedef,auto,delete,inline,short,
    typeid,bool,do,int,signed,typename,break,double,long,sizeof,union,case,
    dynamic_cast,mutable,static,unsigned,catch,else,namespace,static_assert,using,
    char,enum,new,static_cast,virtual,char16_t,char32_t,explict,noexcept,struct,
    void,export,nullptr,switch,volatile,class,extern,operator,template,wchar_t,
    const,false,private,this,while,constexpr,float,protected,thread_local,
    const_cast,for,public,throw,std},
}
\lstset{
    language=verilog,
    basicstyle=\small\ttfamily,
    numbers=left,
    numbersep=5pt,
    xleftmargin=20pt,
    frame=tb,
    framexleftmargin=20pt
}
\renewcommand*\thelstnumber{\arabic{lstnumber}:}
\DeclareCaptionFormat{mylst}{\hrule#1#2#3}
\captionsetup[lstlisting]{format=mylst,labelfont=bf,singlelinecheck=off,labelsep=space}
\makeatletter
\newenvironment{breakablealgorithm}
  {
   \begin{center}
     \refstepcounter{algorithm}
     \hrule heigh!t.8pt depth0pt \kern2pt
     \renewcommand{\caption}[2][\relax]{
       {\raggedrigh!t\textbf{\ALG@name~\thealgorithm} ##2\par}
       \ifx\relax##1\relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}
       \else
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}
       \fi
       \kern2pt\hrule\kern2pt
     }
  }{
     \kern2pt\hrule\relax
   \end{center}
  }

\numberwithin{figure}{subsection}
\numberwithin{table}{subsection}
\makeatletter
\@addtoreset{figure}{subsection}
\@addtoreset{table}{subsection}
\makeatother

\title{Lab 7 - SkipList}
\author{Group 13, Shuting Guo, Ruijia Zhang, Ziyue Tang}
\date{June. $2^{nd}, 2019$}

\begin{document}

\maketitle
\tableofcontents

\chapter{Introduction}
\section{Introduction of Main Task}
This lab project requires a SkipList implement programmed by
C/C++. And then,
test the performance on several cases of data inputs and analyze the complexity of time and space,
and compare with other data structures.

\section{Algorithm specification} 


\chapter{Program Design}

\section{Class Design}
We design a class who has several public
members shown as follows.
\begin{lstlisting}[language=c++]
class SkipList
{
  public:
    void insert(int x);
    bool find(int x);
    void erase(int x);
};
\end{lstlisting}
\begin{enumerate}
\item{\textit{insert} is used to insert an element}
\item{\textit{find} returns true if an element is in the skiplist}
\item{\textit{erase} is used to delete an element}
\end{enumerate}
\textit{Our design allow multiple same elements, and each "erase" method erase one of them.}

\section{Skiplist Implement}

\subsection{insert}
For each rank, we store a list. When we insert an element 'x', we find the largest element 
which is smaller than we are going to insert. We record these elements in an STL vector.
finally, for each element 'p' in the vector, we insert 'x' after 'p'.

\subsection{delete}
Find 'x' so that we can get the position of the heighest node in the skiplist.
We delete the 

\subsection{Update node} Let\ \ \  $height=max\{LeftHight,RightHeight\}+1$.\\
If\ \ \  $|LeftHeight-RightHeight|>1$\ \ \ ,
check the direction of edges that link nodes, and always rotate the higher subtree to lower side.

\section*{Note} For more information and details, see code.



\chapter{Testing}
\section{Correctness}
The correctness is checked by comparing with \texttt{std::set<int>}. Data is generated by 
random generator.
To ensure the correctness of algorithm, we write 4 codes, each use STL \texttt{std::set<int>}, AVL, Splay 
and normal unbalanced BST.

Input $N$ and $N$ commands. Commands are input as following way.\\
\\\indent \texttt{i x} , insert x, output the number of elements in the tree\\
\indent \texttt{d x} , delete x, output the number of elements in the tree\\
\indent \texttt{f x} , find x, output True if x is found, otherwise output False\\
\indent \texttt{l x} , find the element less than x, and output it\\
\indent \texttt{g x} , find the element greater than x, and output it.\\
After all operations, output all elements in the tree in order.

For each random data, for codes run together, then check if four output are same.

\paragraph{Conclusion} For $N=\{3,5,10,50,100,1000,1e4,1e5,1e6\}$ All codes works well, 
and output the same answer on random data (frequency of each operation is same). 

\textit{Note that while testing, all input numbers are non-negative. }

\section{Performance}
We have tested these codes in five situations, and measure the time cost on each,
result is shown as follows.

\subsection{Situation 1}
The same as correctness testing. 

\begin{table}[h!t]
  \centering
  \begin{tabular}{ccccc}
    \toprule
    Algorithm & $1000$ & $1e4$ & $1e5$ & $1e6$\\
    \midrule
    std::set&31ms&33ms&99ms&1141ms\\
    Splay&31ms&47ms&144ms&1419ms\\
    AVL&31ms&47ms&106ms&1132ms\\
    Normal BST&31ms&47ms&126ms&1059ms\\
    \bottomrule
  \end{tabular}
  \caption{Situation 1}
\end{table}

In this case, input is random, so that in normal BST, the shape of tree is tend to be balanced.
Meanwhile, splay is slower because its frequent rotation.

\subsection{Situation 2}
Insert 1-N in order and delete in the same order.

\begin{table}[h!t]
  \centering
  \begin{tabular}{ccccc}
    \toprule
    Algorithm & $1000$ & $1e4$ & $1e5$ & $1e6$\\
    \midrule
    std::set  &28ms&38ms&178ms&1647ms\\
    Splay     &35ms&45ms&169ms&1612ms\\
    AVL       &28ms&46ms&209ms&2138ms\\
    Normal BST&47ms&141ms&9503ms&-\\
    \bottomrule
  \end{tabular}
  \caption{Situation 2}
\end{table}

In this case, AVL needs very frequent rotation to keep balance. And normal BST is grown up to $O(N^2)$ and 
the time cost become unacceptable.

\subsection{Situation 3}
Insert 1-N in order and delete in reversed order.

\begin{table}[h!t]
  \centering
  \begin{tabular}{ccccc}
    \toprule
    Algorithm & $1000$ & $1e4$ & $1e5$ & $1e6$\\
    \midrule
    std::set  &28ms&40ms&177ms&1952ms\\
    Splay     &39ms&47ms&179ms&1776ms\\
    AVL       &35ms&38ms&196ms&2269ms\\
    Normal BST&35ms&231ms&9503ms&-\\
    \bottomrule
  \end{tabular}
  \caption{Situation 3}
\end{table}

The same as Situation 2. But for Splay, in this case, it doesn't needs to do any rotation, just 
link nodes one by one to the root, and delete one by one from root.

\subsection{Situation 4}
Number in range [0,N), insert and delete in random order.

\begin{table}[h!t]
  \centering
  \begin{tabular}{ccccc}
    \toprule
    Algorithm & $1000$ & $1e4$ & $1e5$ & $1e6$\\
    \midrule
    std::set  &32ms&34ms&258ms&3260ms\\
    Splay     &44ms&47ms&319ms&5089ms\\
    AVL       &31ms&46ms&253ms&3352ms\\
    Normal BST&31ms&47ms&211ms&2556ms\\
    \bottomrule
  \end{tabular}
  \caption{Situation 4}
\end{table}

The same as Situation 1.

\subsection{Situation 5}
Insert 1-N in order, then find 0 for N times, find less N+1 for N times, find greater 0 for N times.

\begin{table}[h!t]
  \centering
  \begin{tabular}{ccccc}
    \toprule
    Algorithm & $1000$ & $1e4$ & $1e5$ & $1e6$\\
    \midrule
    std::set  &32ms&48ms&291ms&2971ms\\
    Splay     &46ms&47ms&271ms&2656ms\\
    AVL       &32ms&79ms&357ms&3394ms\\
    Normal BST&31ms&163ms&9611ms&-\\
    \bottomrule
  \end{tabular}
  \caption{Situation 5}
\end{table}

This case is to test whether complexity of query operations are correct.

\begin{figure}[h!t]
  \begin{minipage}{6cm}
    \centering
    \includegraphics[width=6cm]{1.png}
    \caption{Situation 1}
  \end{minipage}
  \begin{minipage}{6cm}
    \centering
    \includegraphics[width=6cm]{2.png}
    \caption{Situation 2}
  \end{minipage}
\end{figure}
\begin{figure}[h!t]
  \begin{minipage}{6cm}
    \centering
    \includegraphics[width=6cm]{3.png}
    \caption{Situation 3}
  \end{minipage}
  \begin{minipage}{6cm}
    \centering
    \includegraphics[width=6cm]{4.png}
    \caption{Situation 4}
  \end{minipage}
\end{figure}
\begin{figure}[h!t]
  \centering
  \includegraphics[width=6cm]{5.png}
  \caption{Situation 5}
\end{figure}

\chapter{Conclusion}
Though these data, we can see, STL set written by RB-tree is very stable and fast. 
Splay is quick when the input is unbalanced, when the input is balanced, 
plenty of rotation slow Splay down.
As for AVL, is highly balanced, so that in random data each operation each time 
cost strict O(logN) time, this is very fast. However, when input is unbalanced, 
inserting can cause more rotation. 

Anyway, these three balanced BST structures guarantee the complexity of insert, delete
and find operation are O(logN), this would not be worse. But in normal BST, 
the shape of tree decides on input, this may cause the degeneration of time complexity,
in worst cases, the time complexity is $O(N^2)$.

\chapter{Appendix: Code}
\section{AVL.cpp}
\begin{lstlisting}[language=c++]
#include <iostream>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <vector>

using namespace std;

#define Debug
#define DEFAULT_MAXN 1000

template<typename _tp,int MAXN=DEFAULT_MAXN>
class AVL
{
  private:
    class AVL_node
    {
      friend class AVL;
      private:
        _tp val;
        AVL_node *l,*r;
        int h; // Height of tree
      public:
        AVL_node():val() { l=r=NULL; h=0; }
        AVL_node(const _tp & x) { val=x; l=r=NULL; h=0; }
    };

    typedef AVL_node node;

    node *U;
    node **Trash,*ALL;
    node *Root;
    int Top,size;

    // Create a new node with value x
    node* ALLOC(const _tp & x)
    { size++; return new(Top?Trash[Top--]:ALL++)node(x); }
    
    // Recycle a node in the tree
    void RECYCLE(node *& t)
    { size--; if(!t) return ; Trash[++Top]=t; return ; }

    int AVL_abs(const int x) { return x>=0?x:-x; }

    // In case of accessing NULL
    int geth(node * t) { return t?t->h:0; }

    // Left-Rotate
    void RotateL(node *& t)
    {
      node *temp=t->r;
      t->r=temp->l;
      temp->l=t; t=temp;
      t->l->h=max(geth(t->l->l),geth(t->l->r))+1;
      t->h=max(geth(t->l),geth(t->r))+1;
      return ;
    }

    // Right-Rotate
    void RotateR(node *& t)
    {
      node *temp=t->l;
      t->l=temp->r;
      temp->r=t; t=temp;
      t->r->h=max(geth(t->r->l),geth(t->r->r))+1;
      t->h=max(geth(t->l),geth(t->r))+1;
      return ;
    }

    // Fix Height after insert or delete
    void update_node(node *& t)
    {
      // Update height
      t->h=max(geth(t->l),geth(t->r))+1;
      // Unbalanced
      if(AVL_abs(geth(t->l) - geth(t->r)) >  1)
      {
        if(geth(t->l) > geth(t->r))
          if(geth(t->l->l) > geth(t->l->r)) RotateR(t);
          else RotateL(t->l), RotateR(t);
        else 
          if(geth(t->r->l) < geth(t->r->r)) RotateL(t);
          else RotateR(t->r), RotateL(t);
      }
    }

    void Insert(node *& t,const _tp & x)
    {
      if(!t) { t=ALLOC(x); t->h=1; return ; }
      if(x==t->val) return ;
      if(x<t->val) Insert(t->l,x);
      else Insert(t->r,x);
      update_node(t);
      return ;
    }

    node * Find(node * t,const _tp & x)
    {
      while(t && x!=t->val)
        if(x < t->val) t=t->l;
        else if(x > t->val) t=t->r;
      return t;
    }

    node * Find_Max(node * t)
    { while(t && t->r) t=t->r; return t; }
    node * Find_Min(node * t)
    { while(t && t->l) t=t->l; return t; }


    void Delete(node *& t,const _tp & x)
    {
      if(!t) { return ; }
      // Found x, delete it
      if(x==t->val)
        if(!t->l && !t->r) RECYCLE(t),t=NULL;
        else if(t->l && !t->r) RECYCLE(t),t=t->l;
        else if(t->r && !t->l) RECYCLE(t),t=t->r;
        // replace t with min node 'P' in left subtree
        //   or max node 'P' in right subtree
        // Delete 'P' recursively
        else
          if(geth(t->l) > geth(t->r))
            t->val=Find_Max(t->l)->val,
            Delete(t->l,t->val);
          else 
            t->val=Find_Min(t->r)->val,
            Delete(t->r,t->val);
      else if(x<t->val) Delete(t->l,x);
      else              Delete(t->r,x);

      // keep balance
      if(t) update_node(t);
      return ;
    }

  protected:
    node * Find_greater(node * t, _tp x)
    {
      node * temp=0;
      while(t)
        if(x<t->val) temp=t,t=t->l;
        else t=t->r;
      return temp;
    }

    node * Find_less(node * t, _tp x)
    {
      node * temp=0;
      while(t)
        if(x<=t->val) t=t->l;
        else temp=t,t=t->r;
      return temp;
    }

    void To_vector(node * t, std::vector<_tp> & vec)
    {
      if(!t) return ;
      To_vector(t->l,vec);
      vec.push_back(t->val);
      To_vector(t->r,vec);
    }

  public:
#ifdef Debug
    void Show_tree() { P(Root); }
    void P(node *t)
    { cout << "***************" << endl; _P(t);
      cout << "***************" << endl; cout << endl; }
    void _P(node * t)
    {
      if(!t) return ;
      if(t->l)
      {cout<<t->val<<" --L-- >"<<t->l->val<<endl;_P(t->l);}
      if(t->r)
      {cout<<t->val<<" --R-- >"<<t->r->val<<endl;_P(t->r);}
    }
#endif
    AVL()
    {
      U=new node[MAXN];
      Trash=new node*[MAXN];
      memset(U,0,sizeof(_tp)*MAXN);
      ALL=U; Top=0; Root=0; size=0;
    }
    ~AVL()
    {
      delete[] U;
      delete[] Trash;
    }

    void Insert(const _tp & x) { Insert(Root,x); }
    bool Find(const _tp & x) { return Find(Root,x); }
    void Delete(const _tp & x) { Delete(Root,x); }
    int Size() { return size; }
    bool Empty() { return size==0; }

    _tp Find_less(const _tp & x)
    {
      node * temp=Find_less(Root,x);
      if(size) return temp?temp->val:Find_Min(Root)->val;
      return _tp();
    }
    _tp Find_greater(const _tp & x)
    {
      node * temp=Find_greater(Root,x);
      if(size) return temp?temp->val:Find_Max(Root)->val;
      return _tp();
    }
    std::vector<_tp> To_vector()
    {
      std::vector<_tp> vec;
      To_vector(Root,vec);
      return vec;
    }
};

int main()
{
  AVL<int,1000000> T;

  int n,x;
  char op[10];
  scanf("%d",&n);
  while(n--)
  {
    scanf("%s",op);
    scanf("%d",&x);
    if(op[0]=='i')
    {
      T.Insert(x);
      printf("%d\n",T.Size());
    }
    else if(op[0]=='d')
    {
      T.Delete(x);
      printf("%d\n",T.Size());
    }
    else if(op[0]=='f')
      printf(T.Find(x)?"True\n":"False\n");
    else if(op[0]=='l')
      printf("%d\n",T.Find_less(x));
    else if(op[0]=='g')
      printf("%d\n",T.Find_greater(x));
    //T.Show_tree();
  }

  vector<int> vec=T.To_vector();
  for(auto it=vec.begin();it!=vec.end();++it)
    printf("%d ",*it);
  printf("\n");

  return 0;
}
\end{lstlisting}

\section{Splay 1}
\begin{lstlisting}[language=c++]
#include <iostream>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <vector>

using namespace std;

#define Debug
#define DEFAULT_MAXN 1000

template<typename _tp,int MAXN=DEFAULT_MAXN>
class Splay
{
  private:
    class Splay_node
    {
      friend class Splay;
      private:
        _tp val;
        Splay_node *fa;
        Splay_node *s[2];
        inline bool getlr() { return fa->s[1]==this; }
        Splay_node * link(const int w, Splay_node * t)
        { if((s[w]=t)) t->fa=this; return this; }
      public:
        Splay_node():val() { s[0]=s[1]=fa=NULL; }
        Splay_node(const _tp & x)
        { val=x; s[0]=s[1]=fa=NULL; }
    };

    typedef Splay_node node;

    node *U,*MinNode,*MaxNode;
    node **Trash,*ALL;
    node *Root;
    int Top,size;

    node* ALLOC(const _tp & x)
    { size++; return new(Top?Trash[Top--]:ALL++)node(x); }
    
    void RECYCLE(node *& t)
    { size--; if(!t) return ; Trash[++Top]=t; return ; }

    void Rotate(node * t)
    {
      node * gfa=t->fa->fa;
      t->getlr()?t->link(0,t->fa->link(1,t->s[0])):
        t->link(1,t->fa->link(0,t->s[1]));
      if(gfa) gfa->link(gfa->s[1]==t->fa,t);
      else t->fa=0,Root=t;
    }

    node * splay(node * t,node * tar=NULL)
    {
      while(t->fa!=tar && t->fa->fa!=tar)
        t->getlr()==t->fa->getlr()?
        (Rotate(t->fa),Rotate(t)):
        (Rotate(t),    Rotate(t));
      if(t->fa!=tar) Rotate(t);
      return t;
    }

    void Insert(node *& t,const _tp & x)
    {
      if(Find(x)) return ;
      node * templ, * tempr, * tempx;
      templ=Find_less(Root,x);
      tempr=Find_greater(Root,x);
      tempx=ALLOC(x);
      if(templ && tempr)
        splay(tempr,splay(templ))->link(0,tempx);
      else if(templ && !tempr)
        Root=tempx->link(0,splay(templ));
      else if(!templ && tempr)
        Root=tempx->link(1,splay(tempr));
      else
        Root=tempx;
    }

    node * Find(node * t,const _tp & x)
    {
      node * last=0;
      while(t && x!=t->val)
      {
        last=t;
        if(x < t->val) t=t->s[0];
        else if(x > t->val) t=t->s[1];
      }
      if(t) splay(t);
      else if(last) splay(last);
      return t;
    }

    node * Find_Max(node * t)
    { while(t && t->s[1]) t=t->s[1]; return t; }
    node * Find_Min(node * t)
    { while(t && t->s[0]) t=t->s[0]; return t; }


    void Delete(node *& t,const _tp & x)
    {
      node * tempx, * templ, * tempr;
      tempx=Find(Root,x);
      if(!tempx) return ;
      templ=Find_less(Root,x);
      tempr=Find_greater(Root,x);
      if(templ && tempr) splay(tempr,splay(templ))->s[0]=0;
      else if(templ && !tempr) splay(templ)->s[1]=0;
      else if(!templ && tempr) splay(tempr)->s[0]=0;
      else                     Root=0;
      RECYCLE(tempx);
    }

  protected:
    node * Find_greater(node * t, _tp x)
    {
      node * temp=0, * last=0;
      while(t)
      {
        last=t;
        if(x<t->val) temp=t,t=t->s[0];
        else t=t->s[1];
      }
      if(temp) splay(temp);
      else if(last) splay(last);
      return temp;
    }

    node * Find_less(node * t, _tp x)
    {
      node * temp=0, * last=0;
      while(t)
      {
        last=t;
        if(x<=t->val) t=t->s[0];
        else temp=t,t=t->s[1];
      }
      if(temp) splay(temp);
      else if(last) splay(last);
      return temp;
    }

    void To_vector(node * t, std::vector<_tp> & vec)
    {
      if(!t) return ;
      _tp temp=Find_Min(Root)->val;
      for(int i=0;i<size;++i)
        vec.push_back(temp),temp=Find_greater(temp);
    }

  public:
#ifdef Debug
    void Show_tree() { P(Root); }
    void P(node *t)
    { cout << "***************" << endl; _P(t);
      cout << "***************" << endl; cout << endl; }
    void _P(node * t)
    {
      if(!t) return ;
      if(t->s[0])
      {cout<<t->val<<" --L-- >"<<t->s[0]->val<<endl;
        _P(t->s[0]);}
      if(t->s[1])
      {cout<<t->val<<" --R-- >"<<t->s[1]->val<<endl;
        _P(t->s[1]);}
    }
#endif
    Splay()
    {
      U=new node[MAXN];
      Trash=new node*[MAXN];
      memset(U,0,sizeof(_tp)*MAXN);
      ALL=U; Top=0; Root=0; size=0;
    }
    ~Splay()
    {
      delete[] U;
      delete[] Trash;
    }

    void Insert(const _tp & x) { Insert(Root,x); }
    bool Find(const _tp & x) { return Find(Root,x); }
    void Delete(const _tp & x) { Delete(Root,x); }
    int Size() { return size; }
    bool Empty() { return size==0; }
    _tp Find_less(const _tp & x)
    {
      node * temp=Find_less(Root,x);
      if(size) return temp?temp->val:Find_Min(Root)->val;
      return _tp();
    }
    _tp Find_greater(const _tp & x)
    {
      node * temp=Find_greater(Root,x);
      if(size) return temp?temp->val:Find_Max(Root)->val;
      return _tp();
    }
    std::vector<_tp> To_vector()
    {
      std::vector<_tp> vec;
      To_vector(Root,vec);
      return vec;
    }
};

int main()
{
  Splay<int,1000000> T;

  int n,x;
  char op[10];
  scanf("%d",&n);
  while(n--)
  {
    scanf("%s",op);
    scanf("%d",&x);
    if(op[0]=='i')
    {
      T.Insert(x);
      printf("%d\n",T.Size());
    }
    else if(op[0]=='d')
    {
      T.Delete(x);
      printf("%d\n",T.Size());
    }
    else if(op[0]=='f')
      printf(T.Find(x)?"True\n":"False\n");
    else if(op[0]=='l')
      printf("%d\n",T.Find_less(x));
    else if(op[0]=='g')
      printf("%d\n",T.Find_greater(x));
    //T.Show_tree();
  }

  vector<int> vec=T.To_vector();
  for(auto it=vec.begin();it!=vec.end();++it)
    printf("%d ",*it);
  printf("\n");

  return 0;
}
\end{lstlisting}

\section{Splay 2}
\begin{lstlisting}[language=c++]
/**************************************************** 
  This Splay Tree will splay from top to bottom,
  and the Splay Tree we learned in class splays
  from bottom to top.(which will cost much more
  space and should use father node.So we choose
  to splay from top to bottom.The link of Tree
  Nodes may be different from the other.But it 
  can be proved that the amortise time is also
  O(Log N).Besides it can reduce the time when we
  need to find a key.
****************************************************/
#include<iostream>
using namespace std;

typedef struct SplayTree* ST;
struct SplayTree
{
  int Key;
  struct SplayTree* Right;
  struct SplayTree* Left;
};

static ST NullNode = NULL;

ST MakeEmpty(ST T);
ST Splay(ST T, int X);
ST FindMin(ST T);
ST FindMax(ST T);
ST Initialize();
ST Insert(ST T, int X);
ST Delete(ST T, int X);

ST RR(ST K2);
ST LL(ST K2);

int main()
{
  ST T = Initialize();
  int N;
  cin>>N;
  while(N--)
  {
    string op;
    int x;
    cin >> op >> x;
    if(op=="i") T=Insert(T,x);
    if(op=="d") T=Delete(T,x);
    if(op=="f")
    {
      T = Splay(T,x);
      cout << (T && T->Key==x?"True":"False") << endl;
    }
  }
} 

ST Initialize()
{
  if(NullNode == NULL)
  {
    NullNode = new SplayTree;
    NullNode->Left = NullNode->Right = NullNode;
  }
  
  return NullNode;
}


ST Splay(ST T,int X)
//Because the find process is to confirm the range of X.
{
  //So the nodes be linked into right tree later must be
  static struct SplayTree Header;
  //smaller than the former nodes.So we linked the new 
  ST LeftTreeMax,  RightTreeMin;
  //nodes into the min node of Right Tree’s left child
  //(which is called right link).And into the max node of 
  Header.Left = Header.Right = NullNode;
  //Left Tree’s Right child(left link).
  LeftTreeMax = RightTreeMin = &Header;
  NullNode->Key = X;
  
  while(X != T->Key)
  {
    if(X < T->Key)
    {
      if(X < T->Left->Key)
      //This situation, we find that the Key we want to find 
        T = RR(T);
        //is in Z and its SubTree. So we first single 
      if(T->Left == NullNode)
      //rotation Y and then right link it.
        break;                    
      
      RightTreeMin->Left = T;
      //This is used when Y has not left child or Y is 
      RightTreeMin = T;
      //key we are find.We let Y be the root of 
      T = T->Left;
      //the middle Tree and right link X.
    }
    else
    {
      if(X > T->Right->Key)
        T = LL(T);
      if(T->Right == NullNode)
        break;
      
      LeftTreeMax->Right = T;
      LeftTreeMax = T;
      T = T->Right;
    }
  }
  
  LeftTreeMax->Right = T->Left;
  //We we finally find X(X is the root of middle tree).
  RightTreeMin->Left = T->Right;
  //We combine the left middle and right tree.
  T->Left = Header.Right;
  //We right link X’s right sub tree and
  //  left link X’s left sub tree.
  T->Right = Header.Left;
  //Then we let right tree be X’s right sub tree 
  //  and left tree be X’s left sub tree.
  //Then we build a new tree with the root X.
  return T;
  //(And if X is not in the tree, 
  //  we let the key which is the most near X be the root.)
} 

ST Insert(ST T,int X)
{
  static ST NewNode = NULL;
  
  if(NewNode == NULL)
  //If T is empty tree,let X be the root and return T.
  {
    NewNode = new SplayTree;
  }
  NewNode->Key = X;
  
  if(T == NullNode)
  {
    NewNode->Left = NewNode->Right = NullNode;
    T = NewNode;
  }
  else
  {
    T = Splay(T, X);
    //Otherwise,Splay the Tree by X.If X is not in the tree,
    if(X < T->Key)
    //then the root must be a number nearly X.
    {
      //Compare X with it,
      //  and link it depend on the situation.
      NewNode->Left = T->Left;
      NewNode->Right = T;
      T->Left = NullNode;
      T = NewNode;
    }
    else if(X > T->Key)
    {
      NewNode->Right = T->Right;
      NewNode->Left = T;
      T->Right = NullNode;
      T = NewNode;
    }
    else return T;
  }
  
  NewNode = NULL;
  return T;
}

ST Delete(ST T, int X)
{
  ST NewTree;
  if(T != NullNode)
  {
    T = Splay(T, X);
    //First,Splay the Tree by X.
    //And if the root is X, 
    //  we can know that X is in the Tree.
    if(X == T->Key)
    {
      if(T->Left == NullNode)
      //If X doesn’t have left child,
      //  let New T = T->Right,then we delete X.
        NewTree = T->Right;
      else
      {
        NewTree = T->Left;
        NewTree = Splay(NewTree, X);
        //And if X have two child.
        //The we splay X’s left sub tree by X,
        NewTree->Right = T->Right;
       //which means that the root of new tree
       //  doesn’t have right sub tree.
      }
      //So we link X’s right sub tree to the new tree.
      delete T;
      T = NewTree;
    }
  }
  
  return T;
}
ST RR(ST K2)
{
  ST K1;
  K1 = K2->Left;
  K2->Left = K1->Right;
  K1->Right = K2;
  
  return K1;
}

ST LL(ST K2)
{
  ST K1;
  K1 = K2->Right;
  K2->Right = K1->Left;
  K1->Left = K2;
  
  return K1;
}

ST MakeEmpty(ST T)
{
  if(T != NULL)
  {
    MakeEmpty(T->Left);
    MakeEmpty(T->Right);
    delete T;
  }
  return NULL;
}
ST FindMin(ST T)
{
  if(T != NULL)
    while(T->Left!=NULL)
      T = T->Left;
  
  return T;
}
ST FindMax(ST T)
{
  if(T != NULL)
    while(T->Right!=NULL)
      T = T->Right;
  
  return T;
}
\end{lstlisting}


\end{document}
